
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>확장성있는 컴포넌트 개발 - 객체지향 스타일 vs 함수형 스타일 - Patrick Yoon</title>
  <meta name="author" content="Patrick Yoon">

  
  <meta name="description" content="Scala in Action의 8장의 내용을 확실히 이해하고자 되새김질 차원에서 하나하나 타이핑해가며 번역하였다. Scala in Action의 8장 제목은 &lsquo;Building scalable and extensible components&#8217;이다. &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://cluno.github.io/blog/2013/10/27/buidling-scalable-components">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Patrick Yoon" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href='http://fonts.googleapis.com/css?family=Quattrocento+Sans|Roboto:400,300' rel='stylesheet' type='text/css'>

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-38934656-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>


<body>
	<div class="container">
		<aside class="left">
			<div class="inner-left">
				<header>
					
  <img src="http://www.gravatar.com/avatar/13f231faa3760fc399725d9f6fb94ee2?s=200" alt="Gravatar of Patrick Yoon " title="Gravatar of Patrick Yoon" class="profilepic" />

<hgroup>
  <h1><a href="/">Patrick Yoon</a></h1>
  
    <h2 class="subtitle">Walking on the clouds</h2>
   
</hgroup>


				</header>
				<footer>
					<p>
	
		<a href="http://github.com/cluno" class="btn btn-dark">GitHub</a>
	
	
		<a href="http://twitter.com/theluno" class="btn btn-dark">Twitter</a>
	
	
		<a href="http://instagram.com/theluno" class="btn btn-dark">Instagram</a>
	
	
		<a href="http://soundcloud.com/pluno" class="btn btn-dark">SoundCloud</a>
	
</p>

				</footer>
			</div>
		</aside>
    	<section class="right">
    		<div class="inner-right">
    			<div id="posts">
    			  	<article class="post">
    
  <header>
    
      <h1 class="entry-title">확장성있는 컴포넌트 개발 - 객체지향 스타일 vs 함수형 스타일</h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-10-27T22:38:00+09:00" pubdate data-updated="true">Oct 27<span>th</span>, 2013</time>
        
      </p>
    
  </header>


<div class="entry-content"><p><a href="http://www.amazon.com/Scala-Action-Nilanjan-Raychaudhuri/dp/1935182757">Scala in Action</a>의 8장의 내용을 확실히 이해하고자 되새김질 차원에서 하나하나 타이핑해가며 번역하였다. <!-- more --></p>

<p>Scala in Action의 8장 제목은 &lsquo;Building scalable and extensible components&#8217;이다. 8장에서 소개되는 문법(추상 타입 멤버, 셀프 타입 멤버, 타입 투영, 팬텀 타입, 타입 클래스 등)에 대한 부분은 생략하고 실무사례로 예로 들고 있는 급여명세 시스템에 대한 부분만 간략히 번역해 보았다.</p>

<h3>재사용</h3>

<p>먼저, 재사용 가능한 컴포넌트를 Scala로 어떻게 작성하는지 간단히 살펴보기 위해 일반적인 주문시스템을 만들어보자.</p>

<p>일반적인 주문시스템은 다음의 컴포넌트로 구성된다.</p>

<ul>
<li>주문(Order) &ndash; 고객이 주문한 내용을 기술.</li>
<li>창고(Inventory) &ndash; 상품을 저장하고 있는 컴포넌트, 주문 전에 상품이 있는지 확인해야 함.</li>
<li>배송(Shipping) &ndash; 고객 주문 처리 방법을 기술.</li>
</ul>


<p>실제는 이보다 더 복잡하지만, 더 큰 컨텍스트로 쉽게 확장할 수 있기 때문에 이 정도로 단순화시키자.</p>

<p>추상 타입 멤버(abstract type memeber)로 주문시스템 컴포넌트를 아래와 같이 추상화할 수 있다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">OderingSystem</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">type</span> <span class="kt">O</span> <span class="k">&lt;:</span> <span class="kt">Order</span>
</span><span class='line'>  <span class="k">type</span> <span class="kt">I</span> <span class="k">&lt;:</span> <span class="kt">Inventory</span>
</span><span class='line'>  <span class="k">type</span> <span class="kt">S</span> <span class="k">&lt;:</span> <span class="kt">Shipping</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>OrderSystem</code>은 3가지 추상 멤버를 선언하고 있다. 동시에 각 타입은 상한을 정하고 있다. 타입 <code>O</code>는 <code>Order</code> 타입의 하위 타입이다. 마찬가지로 <code>I</code>와 <code>S</code>는 <code>Inventory</code>와 <code>Shipping</code>의 하위 타입이다. 따라서, 각 컴포넌트에 대해 <code>Order</code>, <code>Inventory</code>, <code>Shipping</code>의 로직은 다음과 같이 정의할 수 있다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">OrderingSystem</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">type</span> <span class="kt">O</span> <span class="k">&lt;:</span> <span class="kt">Order</span>
</span><span class='line'>  <span class="k">type</span> <span class="kt">I</span> <span class="k">&lt;:</span> <span class="kt">Inventory</span>
</span><span class='line'>  <span class="k">type</span> <span class="kt">S</span> <span class="k">&lt;:</span> <span class="kt">Shipping</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">trait</span> <span class="nc">Order</span> <span class="o">{</span> <span class="k">def</span> <span class="n">placeOrder</span> <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">I</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">}</span>
</span><span class='line'>  <span class="k">trait</span> <span class="nc">Inventory</span> <span class="o">{</span> <span class="k">def</span> <span class="n">itemExits</span><span class="o">(</span><span class="n">order</span><span class="k">:</span> <span class="kt">O</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">}</span>
</span><span class='line'>  <span class="k">trait</span> <span class="nc">Shipping</span> <span class="o">{</span> <span class="k">def</span> <span class="n">scheduleShipping</span><span class="o">(</span><span class="n">order</span><span class="k">:</span> <span class="kt">O</span><span class="o">)</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>모든 컴포넌트를 한 트레이트(trait, 이하 트레이트)로 묶으면 모두가 한 장소에서 집약되고 캡슐화된다는 장점이 있다. 각 컴포넌트의 인터페이스는 갖추었지만, 주문을 하려면 몇 가지 단계를 구현해야한다.</p>

<ul>
<li>창고에 물품이 있는지를 확인.</li>
<li>해당 창고에 대해 주문을 함.</li>
<li>배송 일정을 잡음.</li>
<li>창고에 물건이 없으면 주문을 하지 않고 창고에 제품을 보충하도록 알림.</li>
</ul>


<p><code>OderingSyste</code>에 정의된 <code>Ordering</code> 트레이트에 대해 이 단계들을 구현해보자.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Odering</span> <span class="o">{</span> <span class="k">this:</span> <span class="kt">I</span> <span class="kt">with</span> <span class="kt">S</span> <span class="o">=&gt;</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">placeOrder</span><span class="o">(</span><span class="n">o</span><span class="k">:</span> <span class="kt">O</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span><span class="o">(</span><span class="n">itemExists</span><span class="o">(</span><span class="n">o</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">o</span><span class="o">.</span><span class="n">placeOrder</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span>
</span><span class='line'>          <span class="nc">Some</span><span class="o">(</span><span class="n">scheduleShipping</span><span class="o">(</span><span class="n">o</span><span class="o">))</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="k">else</span> <span class="nc">None</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>placeOrder</code> 메소드는 위에서 언급된 모든 단계들을 셀프 타입 주석(self type annotation)의 은총으로 구현된다. <code>Ordering</code>은 이제 <code>itemExists</code> 메소드의 <code>Inventory</code>와 <code>sheduleShipping</code> 메소드의  <code>Shipping</code>에 의존하게 된다. <code>with</code> 키워드로 다중 셀프 타입 주석을 기술할 수 있음을 주목하자. 이상 다음은 모든 부분들을 합친 주문시스템 컴포넌트이다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">OrderingSystem</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">type</span> <span class="kt">O</span> <span class="k">&lt;:</span> <span class="kt">Order</span>
</span><span class='line'>    <span class="k">type</span> <span class="kt">I</span> <span class="k">&lt;:</span> <span class="kt">Inventory</span>
</span><span class='line'>    <span class="k">type</span> <span class="kt">S</span> <span class="k">&lt;:</span> <span class="kt">Shipping</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">trait</span> <span class="nc">Ordering</span> <span class="o">{</span> <span class="k">this:</span> <span class="kt">I</span> <span class="kt">with</span> <span class="kt">S</span> <span class="o">=&gt;</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">placeOrder</span> <span class="o">(</span><span class="n">o</span><span class="k">:</span> <span class="kt">O</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">if</span><span class="o">(</span><span class="n">itemExists</span><span class="o">(</span><span class="n">o</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">o</span><span class="o">.</span><span class="n">placeOrder</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
</span><span class='line'>                <span class="nc">Some</span><span class="o">(</span><span class="n">scheduleShippng</span><span class="o">(</span><span class="n">o</span><span class="o">))</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="k">else</span> <span class="nc">None</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>OrderingSystem</code>의 추상 타입 멤버들은 이 컴포넌트가 구체적인 구현에 의존하지 않는 서비스임을 나타낸다. 이는 여러가지 상황에서 재사용할 수 있다. 결합 기능으로 <code>Inventory</code>와 <code>Shipping</code> 트레이트를 조립해서 <code>Odering</code> 트레이트를 만들 수 있고, 셀프 타입으로 <code>Ordering</code>은 트레이트 결합으로 제공되는 서비스를 사용할 수 있다. 이 모든 추상은 Scala에서 확장성 있고 재사용성 있는 컴포넌트를 만들 수 있는 블딩블럭을 제공한다. 도서 주문시스템을 구현하고자 할 경우, <code>OderingSystem</code>을 아래와 같이 쉽게 재사용할 수 있다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">object</span> <span class="nc">BookOrderingSystem</span> <span class="k">extends</span> <span class="nc">OrderingSystem</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">type</span> <span class="kt">O</span> <span class="o">=</span> <span class="nc">BookOrder</span>
</span><span class='line'>    <span class="k">type</span> <span class="kt">I</span> <span class="o">=</span> <span class="nc">AmazonBookStore</span>
</span><span class='line'>    <span class="k">type</span> <span class="kt">S</span> <span class="o">=</span> <span class="nc">UPS</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">class</span> <span class="nc">BookOrder</span> <span class="k">extends</span> <span class="nc">Order</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">placeOrder</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">AmazonBookStore</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="kt">...</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">trait</span> <span class="nc">AmazonBookStore</span> <span class="k">extends</span> <span class="nc">Inventory</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">itemExists</span><span class="o">(</span><span class="n">o</span><span class="k">:</span> <span class="kt">BookOrder</span><span class="o">)</span> <span class="k">=</span> <span class="o">...</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">trait</span> <span class="nc">UPS</span> <span class="k">extends</span> <span class="nc">Shipping</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">scheduleShipping</span><span class="o">(</span><span class="n">order</span><span class="k">:</span> <span class="kt">BookOrder</span><span class="o">)</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="o">...</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">object</span> <span class="nc">BookOrdering</span> <span class="k">extends</span> <span class="nc">Ordering</span> <span class="k">with</span> <span class="nc">AmazoneBookStore</span> <span class="k">with</span> <span class="nc">UPS</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>BookOrderingSystem</code>은 구체적인 구현을 모두 제공하며 도서를 주문하는 <code>BookOrdering</code> 객체를 생성한다. 우리가 할 일은 임포트(import, 이하 임포트)해서 <code>BookOrderingSystem</code>을 사용하는 것이 전부다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">import</span> <span class="nn">BookOrderingSystem._</span>
</span><span class='line'><span class="nc">BookOrdering</span><span class="o">.</span><span class="n">placeOrder</span><span class="o">(</span><span class="k">new</span> <span class="nc">BookOrder</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Expression problem과 확장 가능성</h3>

<p>소프트웨어 컴포넌트를 확장해서 현재 소프트웨어 시스템에 기존 소스 코드를 바꾸지 않고 연동하는 것은 소프트웨어 공학이 지닌 근본적인 도전이다. 많은 닝겐들이 <em>Expression problem</em> 을 사용해 객체 지향 상속이 소프트웨어 컴포넌트 확장의 면에서 실패하는 것을 보여주었다. Expression problem은 유형별로 데이터 타입을 정의하는 도전인데, 재컴파일 하지 않고 정적 타입 안정성을 유지하며 데이터 타입의 새 유형과 연산을 추가할 수 있어야 한다는 것이다. 보통 이런 도전은 프로그래밍 언어의 강점과 약점을 증명하는데 쓰인다. Scala에서는 이 문제를 어떻게 풀 수 있는지 살펴보자.</p>

<p>목표는 데이터 타입과 기존 코드의 재컴파일 없이 그러나 정적 타입 안정성(static type safety)은 유지하며 새로운 데이터 타입과 새로운 연산을 정의하는 것이다.</p>

<p>Expression problem은 다음의 요구조건을 모두 만족하며 구현되어야 한다.</p>

<ul>
<li>두 가지 차원에서 확장 가능성. 새 타입의 정의와 모든 타입에 대해 동작하는 연산의 추가.</li>
<li>강력한 정작 타입 안정성. 타입 캐스팅과 리플렉션은 당연한 것임.</li>
<li>기존 코드의 수정이 있어서는 안되며, 중복도 없어야 함.</li>
<li>컴파일 작업은 분리되어야 함.</li>
</ul>


<p>&lsquo;직원 급여명세 시스템&#8217;의 실무 사례로 이 문제를 살펴보자.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Employee</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">trait</span> <span class="nc">Payroll</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">processEmployees</span><span class="o">(</span><span class="n">employees</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Employee</span><span class="o">])</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Throwable</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">USPayroll</span> <span class="k">extends</span> <span class="nc">Payroll</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">processEmployees</span><span class="o">(</span><span class="n">employees</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Employee</span><span class="o">])</span> <span class="k">=</span> <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">CanadaPayroll</span> <span class="k">extends</span> <span class="nc">Payroll</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">processEmployees</span><span class="o">(</span><span class="n">employees</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Employee</span><span class="o">])</span> <span class="k">=</span> <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Payroll</code> 트레이트는 직원 콜렉션을 받아 그들의 급여를 처리하는 <code>processEmployees</code> 메소드를 선언하고 있다. <code>USPayroll</code>과 <code>CanadaPayroll</code>은 개별 국가마다 급여를 처리하는 방법에 따라 <code>processEmployees</code> 메소드를 구현하고 있다.</p>

<p>비지니스의 변화로 인해 일본 직원의 급여도 처리해야 된다고 하자. 간단하다. <code>Payroll</code> 트레이트를 상속하는 다른 클래스를 추가하기만 하면 된다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">class</span> <span class="nc">JapanPayroll</span> <span class="k">extends</span> <span class="nc">Payroll</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">processEmployees</span><span class="o">(</span><span class="n">employees</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Employee</span><span class="o">])</span> <span class="k">=</span> <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>이는 expression problem이 말하는 확장의 한 종류이다. 타입 안정성이란 답을 얻었다. 이제 <code>JapanPayroll</code>을 한 확장으로 추가할 수 있고, 기존 시스템에 컴파일을 분리하여 삽입할 수 있다.</p>

<p>새로운 연산을 추가하려 할 때는 무슨 일이 발생하는가? 이번에는 비지니스가 계약자(contractor)를 고용하기로 결정했고, 이들의 월 급여를 처리해야 한다. 새로운 <code>Payroll</code> 인터페이스는 다음과 같아야 할 것이다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Employee</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Contractor</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">trait</span> <span class="nc">Payroll</span> <span class="k">extends</span> <span class="k">super</span><span class="o">.</span><span class="nc">Payroll</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">processEmployees</span><span class="o">(</span><span class="n">employees</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Employee</span><span class="o">])</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Throwable</span><span class="o">]</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">processContractors</span><span class="o">(</span><span class="n">contractors</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Contractor</span><span class="o">])</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Throwable</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>문제는 전부를 재빌드해야 하기 때문에, expression problem의 제약으로 인해 되돌아가서 트레이트를 수정할 수 없다는 것이다. 수정하지 않고 어떻게 기존 시스템에 기능을 추가할 것인지는 실제적인 문제이다. expression problem 해법의 어려움을 이해하기 위해, 방문자(Visitor) 패턴을 사용해 이 문제를 풀어보자. 다음과 같이 직원 급여를 처리하는 방문자 하나를 만들자.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">USPayroll</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">accept</span><span class="o">(</span><span class="n">v</span><span class="k">:</span> <span class="kt">PayrollVisitor</span><span class="o">)</span> <span class="k">=</span> <span class="n">v</span><span class="o">.</span><span class="n">visit</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">CanadaPayroll</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">accept</span><span class="o">(</span><span class="n">v</span><span class="k">:</span> <span class="kt">PayrollVisitor</span><span class="o">)</span> <span class="k">=</span> <span class="n">v</span><span class="o">.</span><span class="n">visit</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">trait</span> <span class="nc">PayrollVisitor</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">visit</span><span class="o">(</span><span class="n">payroll</span><span class="k">:</span> <span class="kt">USPayroll</span><span class="o">)</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Throwale</span><span class="o">]</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">visit</span><span class="o">(</span><span class="n">payroll</span><span class="k">:</span> <span class="kt">CanadaPayroll</span><span class="o">)</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Throwale</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">EmployeePayrollVisitor</span> <span class="k">extends</span> <span class="nc">PayrollVisitor</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">visit</span><span class="o">(</span><span class="n">payroll</span><span class="k">:</span> <span class="kt">USPayroll</span><span class="o">)</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Throwale</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">visit</span><span class="o">(</span><span class="n">payroll</span><span class="k">:</span> <span class="kt">CanadaPayroll</span><span class="o">)</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Throwale</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>USPayroll</code>과 <code>CanadaPayroll</code> 타입 모두 급여명세(payroll) 방문자를 억셉트한다. 직원들의 급여를 처리하기 위해 <code>EmployeePayrollVisitor</code> 인스턴스를 사용할 것이다. 계약자의 매달 급여를 처리하기 위해, <code>ContractorPayrollVisitor</code>라 불리는 새 클래스를 다음과 같이 쉽게 만들 수 있다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">class</span> <span class="nc">ContractorPayrollVisitor</span> <span class="k">extends</span> <span class="nc">PayrollVisitor</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">visit</span><span class="o">(</span><span class="n">payroll</span><span class="k">:</span> <span class="kt">USPayroll</span><span class="o">)</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Throwable</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">visit</span><span class="o">(</span><span class="n">payroll</span><span class="k">:</span> <span class="kt">CanadaPayroll</span><span class="o">)</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Throwable</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>방문자 패턴을 사용하면, 새 연산을 추가하는 것은 쉽지만, 타입은 어떠한가? <code>JapanPayroll</code>이라 불리는 새 타입을 추가하려면, 되돌아가서 모든 방문자가 <code>JapanPayroll</code>를 허용하도록 수정해야 한다. 첫 번째 해법은 새 타입을 쉽게 추가할 수 있고, 두 번째 해법은 새 연산을 쉽게 추가할 수 있다. 그러나 우리는 두 가지 측면을 모두 처리할 수 있는 해법을 원한다.</p>

<h3>객체지향 스타일</h3>

<p>Scala에서 추상 타입 멤버와 트레이트 결합을 사용해 이 문제를 어떻게 풀어가는지 살펴보자. 동일한 급여명세 시스템을 사용해서, 어떻게 새로운 타입을 추가하는 동시에 타입 안정성을 깨지않고 급여명세 시스템에 새로운 연산을 쉽게 추가할 수 있는지 살펴보자.</p>

<p>아래와 같이 기본 급여명세 시스템을 추상 멤버 타입을 지닌 트레이트로 정의해보자.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">PayrollSystem</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="k">class</span> <span class="nc">Employee</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span>
</span><span class='line'>    <span class="k">type</span> <span class="kt">P</span> <span class="k">&lt;:</span> <span class="kt">Payroll</span>
</span><span class='line'>    <span class="k">trait</span> <span class="nc">Payroll</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">processEmployees</span><span class="o">(</span><span class="n">employees</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Employee</span><span class="o">])</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Throwable</span><span class="o">]</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">processPayroll</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">P</span><span class="o">)</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Throwable</span><span class="o">]</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>모든 것을 한 트레이트에 두게 되면, 이를 모듈로 다룰 수 있다. <code>P</code> 타입은 <code>Payroll</code> 트레이트의 어떤 하위 타입을 의미하는데, 직원들의 급여를 처리하기 위해 추상 메소드로 선언되어 있다. <code>processPayroll</code> 메소드는 주어진 <code>Payroll</code> 타입에 대해 급여명세(payroll)을 처리하기 위해 구현되어야 할 필요가 있다. 아래는 트레이트가 미국과 캐나다 급여명세에 대해 어떻게 확장될 수 있는지 보여준다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">USPayrollSystem</span> <span class="k">extends</span> <span class="nc">PayrollSystem</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">USPayroll</span> <span class="k">extends</span> <span class="nc">Payroll</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">processEmployees</span><span class="o">(</span><span class="n">employees</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Employee</span><span class="o">])</span> <span class="k">=</span> <span class="nc">Left</span><span class="o">(</span><span class="s">&quot;US payroll&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">trait</span> <span class="nc">CanadaPayrollSystem</span> <span class="k">extends</span> <span class="nc">PayrollSystem</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">CanadaPayroll</span> <span class="k">extends</span> <span class="nc">Payroll</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">processEmployees</span><span class="o">(</span><span class="n">employees</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Employee</span><span class="o">])</span> <span class="k">=</span> <span class="nc">Left</span><span class="o">(</span><span class="s">&quot;Canada payroll&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>급여명세 처리의 상세는 생략하였다. 미국 직원들의 급여명세를 처리하기 위해, <code>processPayroll</code> 메소드를 구현함으로써 <code>USPayrollSystem</code>을 구현할 수 있다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">object</span> <span class="nc">USPayrollInstance</span> <span class="k">extends</span> <span class="nc">USPayrollSystem</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">type</span> <span class="kt">P</span> <span class="o">=</span> <span class="nc">USPayroll</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">processPayroll</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">USPayroll</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="n">employees</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Employee</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</span><span class='line'>        <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">p</span><span class="o">.</span><span class="n">processEmployees</span><span class="o">(</span><span class="n">employees</span><span class="o">)</span>
</span><span class='line'>        <span class="o">...</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>이런 설정으로 일본에 대해서 새로운 <code>Payroll</code> 타입을 추가할 수 있다. <code>PayrollSystem</code>을 확장한 트레이트를 만들면 된다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">JapanPayrollSystem</span> <span class="k">extends</span> <span class="nc">PayrollSystem</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">JapanPayroll</span> <span class="k">extends</span> <span class="nc">Payroll</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">processEmployees</span><span class="o">(</span><span class="n">employees</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Employee</span><span class="o">])</span> <span class="k">=</span> <span class="o">...</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>이제 전부를 재컴파일하지 않고 <code>Payroll</code>에 새로운 메소드를 추가하자.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">ContractorPayrollSystem</span> <span class="k">extends</span> <span class="nc">PayrollSystem</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">type</span> <span class="kt">P</span> <span class="k">&lt;:</span> <span class="kt">Payroll</span>
</span><span class='line'>    <span class="k">case</span> <span class="k">class</span> <span class="nc">Contractor</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">trait</span> <span class="nc">Payroll</span> <span class="k">extends</span> <span class="k">super</span><span class="o">.</span><span class="nc">Payroll</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">processContractors</span><span class="o">(</span><span class="n">contractors</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Contractor</span><span class="o">])</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Throwable</span><span class="o">]</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>ContractorPayrollSystem</code> 내에 정의된 <code>Payroll</code> 트레이트는 오버라이딩되지 않고 <code>PayrollSystem</code>으로부터 <code>Payroll</code> 타입의 이전 정의를 가리운다. (※. 이를 쉐도잉(shadowing)이라고 하는 듯..) 이전 <code>ContractPayrollSystem</code> 컨텍스트 안에서 이전 정의는 <code>super</code> 키워드를 사용해 접근할 수 있다. 쉐도잉은 코드에서 예기치 않은 오류를 가져다 줄지도 모르나 이 상황에서는 오버라이딩하지 않고 낡은 <code>Payroll</code> 정의를 확장한다.</p>

<p>주목할만한 또 한가지는 추상 멤버 타입 <code>P</code>를 재정의하고 있다는 것이다. <code>P</code>는 <code>processEmployees</code> 메소드와 <code>processContractors</code> 메소드 모두를 이해하는 <code>Payroll</code>의 하위 타입이 될 필요가 있다. 계약자(contractor)를 미국과 캐나다 모두에 대해 처리하기 위해, <code>ContractPayrollSystem</code> 트레이트를 확장하자.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">USContractorPayrollSystem</span> <span class="k">extends</span> <span class="nc">USPayrollSystem</span> <span class="k">with</span> <span class="nc">ContractorPayrollSystem</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">USPayroll</span> <span class="k">extends</span> <span class="k">super</span><span class="o">.</span><span class="nc">USPayroll</span> <span class="k">with</span> <span class="nc">Payroll</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">processContractors</span><span class="o">(</span><span class="n">contractors</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Contractor</span><span class="o">])</span> <span class="k">=</span> <span class="nc">Left</span><span class="o">(</span><span class="s">&quot;US contract payroll&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">trait</span> <span class="nc">CanadaContractorPayrollSystem</span> <span class="k">extends</span> <span class="nc">CanadaPayrollSystem</span> <span class="k">with</span> <span class="nc">ContractorPayrollSystem</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">CanadaPayroll</span> <span class="k">extends</span> <span class="k">super</span><span class="o">.</span><span class="nc">CanadaPayroll</span> <span class="k">with</span> <span class="nc">Payroll</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">processContractors</span><span class="o">(</span><span class="n">contractors</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Contractor</span><span class="o">])</span> <span class="k">=</span> <span class="nc">Left</span><span class="o">(</span><span class="s">&quot;Canada contract payroll&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>USPayroll</code>과 <code>CanadaPayroll</code>의 이전 정의를 쉐도잉하고 있다. 또한 <code>processContractors</code> 메소드를 구현하기 위해 <code>Payroll</code> 트레이트의 새로운 정의를 결합하고 있다. 타입 안정성 요구사항을 기억하자. <code>Payroll</code> 트레이트를 결합하지 않으면, <code>USContractorPayrollSystem</code>나 <code>CanadaContractorPayrollSystem</code>의 구체적인 구현을 만들 때 오류를 얻게 된다. 마찬가지로 <code>processContractors</code> 연산를 <code>JapanPayrollSystem</code>에 추가할 수 있다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">JapanContractorPayrollSystem</span> <span class="k">extends</span> <span class="nc">JapanPayrollSystem</span> <span class="k">with</span> <span class="nc">ContractorPayrollSystem</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">JapanPayroll</span> <span class="k">extends</span> <span class="k">super</span><span class="o">.</span><span class="nc">JapanPayroll</span> <span class="k">with</span> <span class="nc">Payroll</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">processContractors</span><span class="o">(</span><span class="n">contractors</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Contractor</span><span class="o">])</span> <span class="k">=</span> <span class="nc">Left</span><span class="o">(</span><span class="s">&quot;Japan contract payroll&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>현 시점에서 expression problem을 성공적으로 풀어보았다. 다음은 전체 코드이다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">package</span> <span class="nn">chap08.payroll</span>
</span><span class='line'>
</span><span class='line'><span class="k">trait</span> <span class="nc">PayrollSystem</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="k">class</span> <span class="nc">Employee</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span>
</span><span class='line'>    <span class="k">type</span> <span class="kt">P</span> <span class="k">&lt;:</span> <span class="kt">Payroll</span>
</span><span class='line'>    <span class="k">trait</span> <span class="nc">Payroll</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">processEmployees</span><span class="o">(</span><span class="n">employees</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Employee</span><span class="o">])</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Throwable</span><span class="o">]</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">processPayroll</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">P</span><span class="o">)</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Throwable</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">trait</span> <span class="nc">USPayrollSystem</span> <span class="k">extends</span> <span class="nc">PayrollSystem</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">USPayroll</span> <span class="k">extends</span> <span class="nc">Payroll</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">processEmployees</span><span class="o">(</span><span class="n">employees</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Employee</span><span class="o">])</span> <span class="k">=</span> <span class="nc">Left</span><span class="o">(</span><span class="s">&quot;US payroll&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">trait</span> <span class="nc">CanadaPayrollSystem</span> <span class="k">extends</span> <span class="nc">PayrollSystem</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">CanadaPayroll</span> <span class="k">extends</span> <span class="nc">Payroll</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">processEmployees</span><span class="o">(</span><span class="n">employees</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Employee</span><span class="o">])</span> <span class="k">=</span> <span class="nc">Left</span><span class="o">(</span><span class="s">&quot;Canada payroll&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">trait</span> <span class="nc">JapanPayrollSystem</span> <span class="k">extends</span> <span class="nc">PayrollSystem</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">JapanPayroll</span> <span class="k">extends</span> <span class="nc">Payroll</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">processEmployees</span><span class="o">(</span><span class="n">employees</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Employee</span><span class="o">])</span> <span class="k">=</span> <span class="nc">Left</span><span class="o">(</span><span class="s">&quot;Japan payroll&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">trait</span> <span class="nc">ContractorPayrollSystem</span> <span class="k">extends</span> <span class="nc">PayrollSystem</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">type</span> <span class="kt">P</span> <span class="k">&lt;:</span> <span class="kt">Payroll</span>
</span><span class='line'>    <span class="k">case</span> <span class="k">class</span> <span class="nc">Contractor</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</span><span class='line'>    <span class="k">trait</span> <span class="nc">Payroll</span> <span class="k">extends</span> <span class="k">super</span><span class="o">.</span><span class="nc">Payroll</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">processContractors</span><span class="o">(</span><span class="n">contractors</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Contractor</span><span class="o">])</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Throwable</span><span class="o">]</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">trait</span> <span class="nc">USContractorPayrollSystem</span> <span class="k">extends</span> <span class="nc">USPayrollSystem</span> <span class="k">with</span> <span class="nc">ContractorPayrollSystem</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">USPayroll</span> <span class="k">extends</span> <span class="k">super</span><span class="o">.</span><span class="nc">USPayroll</span> <span class="k">with</span> <span class="nc">Payroll</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">processContractors</span><span class="o">(</span><span class="n">contractors</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Contractor</span><span class="o">])</span> <span class="k">=</span> <span class="nc">Left</span><span class="o">(</span><span class="s">&quot;US contract payroll&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">trait</span> <span class="nc">CanadaContractorPayrollSystem</span> <span class="k">extends</span> <span class="nc">CanadaPayrollSystem</span> <span class="k">with</span> <span class="nc">ContractorPayrollSystem</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">CanadaPayroll</span> <span class="k">extends</span> <span class="k">super</span><span class="o">.</span><span class="nc">CanadaPayroll</span> <span class="k">with</span> <span class="nc">Payroll</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">processContractors</span><span class="o">(</span><span class="n">contractors</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Contractor</span><span class="o">])</span> <span class="k">=</span> <span class="nc">Left</span><span class="o">(</span><span class="s">&quot;Canada contract payroll&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">trait</span> <span class="nc">JapanContractorPayrollSystem</span> <span class="k">extends</span> <span class="nc">JapanPayrollSystem</span> <span class="k">with</span> <span class="nc">ContractorPayrollSystem</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">JapanPayroll</span> <span class="k">extends</span> <span class="k">super</span><span class="o">.</span><span class="nc">JapanPayroll</span> <span class="k">with</span> <span class="nc">Payroll</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">processContractors</span><span class="o">(</span><span class="n">contractors</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Contractor</span><span class="o">])</span> <span class="k">=</span> <span class="nc">Left</span><span class="o">(</span><span class="s">&quot;Japan contract payroll&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Scala 일급 모듈(first-class module) 지원을 사용하면, 모든 트레이트와 클래스를 한 객체로 포장하고 전부를 재컴파일하지 않으면서 또 동시에 타입 안정성을 유지하며 기존 소프트웨어 컴포넌트를 확장할 수 있다. 구버전과 새버전의 <code>Payroll</code> 모두 이용할 수 있다는 점, 구성하는 트레이트에 의해 동작들이 조정되는 점을 주목하라. 직원과 계약자들 모두를 처리하기 위해 새 <code>Payroll</code>을 사용하려면, <code>ContractorPayrollSystem</code> 트레이트 중 하나를 결합해야 한다. 다음의 예제는 <code>USContractorPayrollSystem</code> 인스턴스를 어떻게 만드는지를 보여준다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">object</span> <span class="nc">RunNewPayroll</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">object</span> <span class="nc">USNewPayrollInstance</span> <span class="k">extends</span> <span class="nc">USContractorPayrollSystem</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">type</span> <span class="kt">P</span> <span class="o">=</span> <span class="nc">USPayroll</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">processPayroll</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">USPayroll</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">p</span><span class="o">.</span><span class="n">processEmployees</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="nc">Employee</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="mi">1</span><span class="o">)))</span>
</span><span class='line'>            <span class="n">p</span><span class="o">.</span><span class="n">processContractors</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="nc">Contractor</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">)))</span>
</span><span class='line'>            <span class="nc">Left</span><span class="o">(</span><span class="s">&quot;payroll processed successfully&quot;</span><span class="o">)</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">run</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">run</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="n">usPayroll</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">USPayroll</span>
</span><span class='line'>        <span class="nc">USNewPayrollInstance</span><span class="o">.</span><span class="n">processPayroll</span><span class="o">(</span><span class="n">usPayroll</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>processPayroll</code> 메소드는 <code>Payroll</code> 트레이트의 <code>processEmployees</code>와 <code>processContractors</code> 둘 다를 호출하지만, 대신에 미국 직원의 급여를 어떻게 처리해야 할지 아는 기존 급여명세 시스템을 쉽게 사용할 수 있다. 왜냐하면 <code>USPayroll</code> 트레이트를 여전히 확신할 수 있기 때문이다. 남은 것은 추가적인 <code>processContractors</code> 부분을 구현하는 것이다.</p>

<p>이상, 우리는 객체 지향 추상 가능성(Object oriented abstractions available)을 사용해 풀어보았다.</p>

<h3>함수형 스타일</h3>

<p>이제 함수형 프로그래밍 차원에서 접근해보자.</p>

<p>급여명세(payroll) 프로세스는 두 가지 추상화에 의해 주도된다. 하나는 급여명세를 처리하는 국가(country)고 하나는 피지불인(payee)이다.<code>USPayroll</code> 클래스는 다음과 같을 것이다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">USPayroll</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">payees</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">processPayroll</span> <span class="k">=</span> <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>타입 <code>A</code>는 피지불인의 타입을 나타낸다. 이는 직원일 수 있고, 계약자일 수 있다. 비슷하게 캐나다 급여명세 클래스는 다음과 같을 것이다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">CanadaPayroll</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">payees</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">processPayroll</span> <span class="k">=</span> <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>급여명세 프로세서 패밀리에 대한 유형 클래스를 나타내기 위해, 국가와 피지불인의 유형을 다음과 같이 매개변수화하여 다음의 트레이트를 정의할 수 있다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">import</span> <span class="nn">scala.language.higherKinds</span>
</span><span class='line'><span class="k">trait</span> <span class="nc">PayrollProcessor</span><span class="o">[</span><span class="kt">C</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">processPayroll</span><span class="o">(</span><span class="n">payees</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Throwable</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>C</code>는 급여명세 유형을 나타내는 고차 존재(higher-kinded) 타입이다. 고차 존재 타입인 이유는 <code>USPayroll</code>과 <code>CanadaPayroll</code> 둘 다 타입 매개변수를 취하기 때문이다. <code>A</code>는 피지불인 유형을 나타내는 타입이다. 팬텀 타입(phamtom type)처럼 매개변수화된 타입을 제외하고는 <code>C</code>를 사용하지 않는다는 것을 주목하라. 타입 클래스의 두 번째 빌딩블럭인 <code>PayrollProcessor</code> 트레이트의 임플리시트(implicit, 이하 임플리시트) 정의는 다음과 같다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Employee</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span>
</span><span class='line'><span class="k">implicit</span> <span class="k">object</span> <span class="nc">USPayrollProcessor</span> <span class="k">extends</span> <span class="nc">PayrollProcessor</span><span class="o">[</span><span class="kt">USPayroll</span>, <span class="kt">Employee</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">processPayroll</span><span class="o">(</span><span class="n">payees</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Employee</span><span class="o">])</span> <span class="k">=</span> <span class="nc">Left</span><span class="o">(</span><span class="s">&quot;us employees are processed&quot;</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">implicit</span> <span class="k">object</span> <span class="nc">CanadaPayrollProcessor</span> <span class="k">extends</span> <span class="nc">PayrollProcessor</span><span class="o">[</span><span class="kt">CanadaPayroll</span>, <span class="kt">Employee</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">processPayroll</span><span class="o">(</span><span class="n">payees</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Employee</span><span class="o">])</span> <span class="k">=</span> <span class="nc">Left</span><span class="o">(</span><span class="s">&quot;canada employees are processed&quot;</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>국가에 따라 적절한 <code>PayrollProcessor</code>의 정의를 식별하기 위해 <code>PayrollProcessor</code>의 첫번째 타입 매개변수를 어떻게 사용하는지 살펴보자. 임플리시트 정의를 가져다 쓸려면, <code>USPayroll</code> 과 <code>CanadaPayroll</code> 타입에 모두에 대해 임플리시트 클래스 매개변수를  다음과 같이 정의해야 한다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">USPayroll</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">payees</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">processor</span><span class="k">:</span> <span class="kt">PayrollProcessor</span><span class="o">[</span><span class="kt">USPayroll</span>, <span class="kt">A</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">processPayroll</span> <span class="k">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">processPayroll</span><span class="o">(</span><span class="n">payees</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">CanadaPayroll</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">payees</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">processor</span><span class="k">:</span> <span class="kt">PayrollProcessor</span><span class="o">[</span><span class="kt">CanadaPayroll</span>, <span class="kt">A</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">processPayroll</span> <span class="k">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">processPayroll</span><span class="o">(</span><span class="n">payees</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>이제 <code>USPayroll</code>과 <code>CanadaPayroll</code> 인스턴스를 만들면, Scala 컴파일러가 임플리시트 매개변수에 대한 값을 공급한다. 지금까지의 소스는 다음과 같다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">package</span> <span class="nn">chap08.payroll.typeclass</span>
</span><span class='line'><span class="k">import</span> <span class="nn">scala.langage.higherkinds</span>
</span><span class='line'>
</span><span class='line'><span class="k">object</span> <span class="nc">PayrollSystemWithTypeclass</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="k">class</span> <span class="nc">Employee</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">trait</span> <span class="nc">PayrollProcessor</span><span class="o">[</span><span class="kt">C</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">processPayroll</span><span class="o">(</span><span class="n">payees</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Throwable</span><span class="o">]</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">case</span> <span class="k">class</span> <span class="nc">USPayroll</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">payees</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">processor</span><span class="k">:</span> <span class="kt">PayrollProcessor</span><span class="o">[</span><span class="kt">USPayroll</span>, <span class="kt">A</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">processPayroll</span> <span class="k">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">processPayroll</span><span class="o">(</span><span class="n">payees</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">case</span> <span class="k">class</span> <span class="nc">CanadaPayroll</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">payees</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">processor</span><span class="k">:</span> <span class="kt">PayrollProcessor</span><span class="o">[</span><span class="kt">CanadaPayroll</span>, <span class="kt">A</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">processPayroll</span> <span class="k">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">processPayroll</span><span class="o">(</span><span class="n">payees</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">object</span> <span class="nc">PayrollProcessors</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">import</span> <span class="nn">PayrollSystemWithTypeclass._</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">implicit</span> <span class="k">object</span> <span class="nc">USPayrollProcessor</span> <span class="k">extends</span> <span class="nc">PayrollProcessor</span><span class="o">[</span><span class="kt">USPayroll</span>, <span class="kt">Employee</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">processPayroll</span><span class="o">(</span><span class="n">payees</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Employee</span><span class="o">])</span> <span class="k">=</span> <span class="nc">Left</span><span class="o">(</span><span class="s">&quot;us employees are processed&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">implicit</span> <span class="k">object</span> <span class="nc">CanadaPayrollProcessor</span> <span class="k">extends</span> <span class="nc">PayrollProcessor</span><span class="o">[</span><span class="kt">CanadaPayroll</span>, <span class="kt">Employee</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">payees</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Employee</span><span class="o">])</span> <span class="k">=</span> <span class="nc">Left</span><span class="o">(</span><span class="s">&quot;canada employees are processed&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">object</span> <span class="nc">RunPayroll</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">import</span> <span class="nn">PayrollSystemWithTypeclass._</span>
</span><span class='line'>    <span class="k">import</span> <span class="nn">PayrollProcessors._</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">run</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">run</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="nc">USPayroll</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="nc">Employee</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="n">a</span><span class="o">))).</span><span class="n">processPayroll</span>
</span><span class='line'>        <span class="n">println</span><span class="o">(</span><span class="n">r</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>모든 임플리시트 정의들은 함께 그룹화되어, <code>RunPayroll</code> 객체 안으로, 임포트될 수 있게 거들고 있다. 직원 콜렉션을 제공하는 <code>USPayroll</code>를 인스턴스화할 때 임플리시트 프로세서가 공급됨을 주목하라. 이 경우에는 <code>USPayrollProcessor</code>가 이에 해당한다.</p>

<p>이제 타입 안정성(type satefy)도 지녔는지 검증해보자. <code>Contractor</code>라 불리는 새 타입을 만들자.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Contractor</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>피지불인 유형에 대한 제약사항이 없기 때문에, 쉽게 계약자 콜렉션을 만들어 <code>USPayroll</code>에 전달할 수 있다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nc">USPayroll</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="nc">Contractor</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">))).</span><span class="n">processPayroll</span>
</span></code></pre></td></tr></table></div></figure>


<p>그러나 위 라인을 컴파일하는 순간, 컴파일 에러가 발생한다. 왜냐하면 아직 <code>USPayroll</code> 과 <code>Contractor</code>에 대한 암묵적인 정의가 없기 때문이다.</p>

<p>현재 구성에서 새 타입을 추가하는 것은 매우 쉽다. 새 클래스를 추가해서 급여명세 프로세서에 임플리시트를 정의하면 된다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">object</span> <span class="nc">PayrollSystemWithTypeclassExtension</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">import</span> <span class="nn">PayrollSystemWithTypeclass._</span>
</span><span class='line'>    <span class="k">case</span> <span class="k">class</span> <span class="nc">JapanPayroll</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">payees</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">processor</span><span class="k">:</span> <span class="kt">PayrollProcessor</span><span class="o">[</span><span class="kt">JapanPayroll</span>, <span class="kt">A</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">processPayroll</span> <span class="k">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">processPayroll</span><span class="o">(</span><span class="n">payees</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">case</span> <span class="k">class</span> <span class="nc">Contractor</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">object</span> <span class="nc">PayrollProcessorsExtension</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">import</span> <span class="nn">PayrollSystemWithTypeclassExtension._</span>
</span><span class='line'>    <span class="k">import</span> <span class="nn">PayrollSystemWithTypeclass._</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">implicit</span> <span class="k">object</span> <span class="nc">JapanPayrollProcessor</span> <span class="k">extends</span> <span class="nc">PayrollProcessor</span><span class="o">[</span><span class="kt">JapanPayroll</span>, <span class="kt">Employee</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">def</span> <span class="n">processPayroll</span><span class="o">(</span><span class="n">payees</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Employee</span><span class="o">])</span> <span class="k">=</span> <span class="nc">Left</span><span class="o">(</span><span class="s">&quot;japan employees are processed&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>계약자 B에 대한 급여를 지불하는 새 연산도 매우 간단하다. 아래와 같이 계약자에 대한 임플리시트를 정의하면 된다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">implicit</span> <span class="k">object</span> <span class="nc">USContractorPayrollProcessor</span> <span class="k">extends</span> <span class="nc">PayrollProcessor</span><span class="o">[</span><span class="kt">USPayroll</span>, <span class="kt">Contractor</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">processPayroll</span><span class="o">(</span><span class="n">payees</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Contractor</span><span class="o">])</span> <span class="k">=</span> <span class="nc">Left</span><span class="o">(</span><span class="s">&quot;us contractors are processed&quot;</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">implicit</span> <span class="k">object</span> <span class="nc">CanadaContractorPayrollProcessor</span> <span class="k">extends</span> <span class="nc">PayrollProcessor</span><span class="o">[</span><span class="kt">CanadaPayroll</span>, <span class="kt">Contractor</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">processPayroll</span><span class="o">(</span><span class="n">payees</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Contractor</span><span class="o">])</span> <span class="k">=</span> <span class="nc">Left</span><span class="o">(</span><span class="s">&quot;canada contractors are processed&quot;</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">implicit</span> <span class="k">object</span> <span class="nc">JapanContractorPayrollProcessor</span> <span class="k">extends</span> <span class="nc">PayrollProcessor</span><span class="o">[</span><span class="kt">JapanPayroll</span>, <span class="kt">Contractor</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">processPayroll</span><span class="o">(</span><span class="n">payees</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Contractor</span><span class="o">])</span> <span class="k">=</span> <span class="nc">Left</span><span class="o">(</span><span class="s">&quot;japan contractors are processed&quot;</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>위의 임플리시트 정의들을 <code>PayrollProcessorsExtension</code> 객체 안에 추가하면, 모두를 함께 그룹지을 수 있다. 다음의 코드 조각은 직원과 계약자 모두의 급여를 지불하기 위한 코드를 어떻게 사용하지는 보여주고 있다.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">object</span> <span class="nc">RunNewPayroll</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">import</span> <span class="nn">PayrollSystemWithTypeclass._</span>
</span><span class='line'>    <span class="k">import</span> <span class="nn">PayrollProcessors._</span>
</span><span class='line'>    <span class="k">import</span> <span class="nn">PayrollSystemWithTypeclassExtension._</span>
</span><span class='line'>    <span class="k">import</span> <span class="nn">PayrollProcessorsExtension._</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">run</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">run</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="n">r1</span> <span class="k">=</span> <span class="nc">JapanPayroll</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="nc">Employee</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="mi">1</span><span class="o">))).</span><span class="n">processPayroll</span>
</span><span class='line'>        <span class="k">val</span> <span class="n">r2</span> <span class="k">=</span> <span class="nc">JapanPayroll</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="nc">Contractor</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">))).</span><span class="n">processPayroll</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>보다시피 필요한 클래스와 임플리시트 정의를 모두 임포트해서 일본에 대해 급여를 처리하고 있다. 이번에는 함수형 프로그래밍 기술을 사용하여 Expression problem을 거듭 성공적으로 풀었다. 자바 프로그래머들은 타입 클래스에 익숙해지는데에 다소 시간이 걸릴지도 모르지만, 한번 익숙해지게 되면 변경에 재빠르게 반응하는 소급 모델(retroactive model)의 파워를 갖추게 될 것이다.</p>

<h3>나가며</h3>

<p>Scala in Action의 8장에서는 Scala의 재사용성과 확장성을 보여주기 위해 Expression problem을 실무 사례와 비슷한 급여명세 시스템에 적용하며 객체지향 프로그래밍(OOP)과 함수형 프로그래밍(FP) 스타일의 해법을 제시하고 있다. OOP에서는 추상 멤버 타입과 트레이트 결합을, FP에서는 팬텀 타입(Phantom Type)과 임플리시트(implicit)를 사용하고 있다. 개인적으로는 아무래도 OOP 스타일이 더 익숙하지만, 임플리시트로 팬텀 타입(Phantom Type)에서 사용하는 타입을 준비하고 타입 매개변수에서 필요한 특정 타입을 지정하면 나머지는 컴파일러가 알아서 처리하는 FP 스타일의 간결함과 유연함이 좀 더 좋아보인다.</p>

<h3>더 읽을거리</h3>

<ul>
<li><a href="http://www.slideshare.net/maedaunderscore/phatom-type-14612078">Phantom Type in Scala (Japanese, 2013)</a></li>
<li><a href="http://docs.scala-lang.org/overviews/core/architecture-of-scala-collections.html">The Architecture of Scala Collections</a></li>
<li><a href="http://stackoverflow.com/questions/7860163/what-are-some-compelling-use-cases-for-dependent-method-types">What are some compelling use cases for dependent method types?</a></li>
<li><a href="http://ropas.snu.ac.kr/~bruno/papers/TypeClasses.pdf">Type Classes as Objects and Implicits (2010)</a></li>
<li><a href="http://808fabrik.com/scala/functor-monad-in-scala-handout.pdf">From Functor to Monad (2013.02)</a></li>
<li><a href="http://tmorris.net/posts/functors-and-things-using-scala/index.html">Functors and things using Scala (2013.03)</a></li>
<li><a href="http://apocalisp.wordpress.com/2010/06/08/type-level-programming-in-scala/">Type-Level Programming (2010.06)</a></li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.117.695">On understanding types, data abstraction, and polymorphism (1985)</a></li>
</ul>

</div>


</article>


        <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://cluno.github.io/blog/2013/10/27/buidling-scalable-components/" data-via="theluno" data-counturl="http://cluno.github.io/blog/2013/10/27/buidling-scalable-components/" >Tweet</a>
  
  
  
    <div class="fb-like" data-send="true" data-width="450" data-show-faces="false"></div>
  
</div>




<section id="comments">
    <div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>


    			</div>
    			<footer id="footer">
    				<p class="credit">
  Copyright &copy; 2014 - Patrick Yoon. Powered by <a href="http://octopress.org">Octopress</a>
</p>


    			</footer>
    			

<script type="text/javascript">
      var disqus_shortname = 'theluno';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://cluno.github.io/blog/2013/10/27/buidling-scalable-components/';
        var disqus_url = 'http://cluno.github.io/blog/2013/10/27/buidling-scalable-components/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>





  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>




<link href='http://fonts.googleapis.com/css?family=Quattrocento+Sans|Roboto:400,300' rel='stylesheet' type='text/css'>


  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-38934656-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>




    		</div>
    	</section>
  	</div>
</body>
</html>
